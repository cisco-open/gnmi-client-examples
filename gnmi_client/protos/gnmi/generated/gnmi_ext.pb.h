// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gnmi_ext.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gnmi_5fext_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gnmi_5fext_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/duration.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gnmi_5fext_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gnmi_5fext_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gnmi_5fext_2eproto;
namespace gnmi_ext {
class Commit;
struct CommitDefaultTypeInternal;
extern CommitDefaultTypeInternal _Commit_default_instance_;
class CommitCancel;
struct CommitCancelDefaultTypeInternal;
extern CommitCancelDefaultTypeInternal _CommitCancel_default_instance_;
class CommitConfirm;
struct CommitConfirmDefaultTypeInternal;
extern CommitConfirmDefaultTypeInternal _CommitConfirm_default_instance_;
class CommitRequest;
struct CommitRequestDefaultTypeInternal;
extern CommitRequestDefaultTypeInternal _CommitRequest_default_instance_;
class CommitSetRollbackDuration;
struct CommitSetRollbackDurationDefaultTypeInternal;
extern CommitSetRollbackDurationDefaultTypeInternal _CommitSetRollbackDuration_default_instance_;
class Depth;
struct DepthDefaultTypeInternal;
extern DepthDefaultTypeInternal _Depth_default_instance_;
class Extension;
struct ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class History;
struct HistoryDefaultTypeInternal;
extern HistoryDefaultTypeInternal _History_default_instance_;
class MasterArbitration;
struct MasterArbitrationDefaultTypeInternal;
extern MasterArbitrationDefaultTypeInternal _MasterArbitration_default_instance_;
class RegisteredExtension;
struct RegisteredExtensionDefaultTypeInternal;
extern RegisteredExtensionDefaultTypeInternal _RegisteredExtension_default_instance_;
class Role;
struct RoleDefaultTypeInternal;
extern RoleDefaultTypeInternal _Role_default_instance_;
class TimeRange;
struct TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class Uint128;
struct Uint128DefaultTypeInternal;
extern Uint128DefaultTypeInternal _Uint128_default_instance_;
}  // namespace gnmi_ext
PROTOBUF_NAMESPACE_OPEN
template<> ::gnmi_ext::Commit* Arena::CreateMaybeMessage<::gnmi_ext::Commit>(Arena*);
template<> ::gnmi_ext::CommitCancel* Arena::CreateMaybeMessage<::gnmi_ext::CommitCancel>(Arena*);
template<> ::gnmi_ext::CommitConfirm* Arena::CreateMaybeMessage<::gnmi_ext::CommitConfirm>(Arena*);
template<> ::gnmi_ext::CommitRequest* Arena::CreateMaybeMessage<::gnmi_ext::CommitRequest>(Arena*);
template<> ::gnmi_ext::CommitSetRollbackDuration* Arena::CreateMaybeMessage<::gnmi_ext::CommitSetRollbackDuration>(Arena*);
template<> ::gnmi_ext::Depth* Arena::CreateMaybeMessage<::gnmi_ext::Depth>(Arena*);
template<> ::gnmi_ext::Extension* Arena::CreateMaybeMessage<::gnmi_ext::Extension>(Arena*);
template<> ::gnmi_ext::History* Arena::CreateMaybeMessage<::gnmi_ext::History>(Arena*);
template<> ::gnmi_ext::MasterArbitration* Arena::CreateMaybeMessage<::gnmi_ext::MasterArbitration>(Arena*);
template<> ::gnmi_ext::RegisteredExtension* Arena::CreateMaybeMessage<::gnmi_ext::RegisteredExtension>(Arena*);
template<> ::gnmi_ext::Role* Arena::CreateMaybeMessage<::gnmi_ext::Role>(Arena*);
template<> ::gnmi_ext::TimeRange* Arena::CreateMaybeMessage<::gnmi_ext::TimeRange>(Arena*);
template<> ::gnmi_ext::Uint128* Arena::CreateMaybeMessage<::gnmi_ext::Uint128>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gnmi_ext {

enum ExtensionID : int {
  EID_UNSET = 0,
  EID_EXPERIMENTAL = 999,
  ExtensionID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExtensionID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExtensionID_IsValid(int value);
constexpr ExtensionID ExtensionID_MIN = EID_UNSET;
constexpr ExtensionID ExtensionID_MAX = EID_EXPERIMENTAL;
constexpr int ExtensionID_ARRAYSIZE = ExtensionID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExtensionID_descriptor();
template<typename T>
inline const std::string& ExtensionID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExtensionID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExtensionID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExtensionID_descriptor(), enum_t_value);
}
inline bool ExtensionID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExtensionID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExtensionID>(
    ExtensionID_descriptor(), name, value);
}
// ===================================================================

class Extension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.Extension) */ {
 public:
  inline Extension() : Extension(nullptr) {}
  ~Extension() override;
  explicit constexpr Extension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Extension(const Extension& from);
  Extension(Extension&& from) noexcept
    : Extension() {
    *this = ::std::move(from);
  }

  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline Extension& operator=(Extension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Extension& default_instance() {
    return *internal_default_instance();
  }
  enum ExtCase {
    kRegisteredExt = 1,
    kMasterArbitration = 2,
    kHistory = 3,
    kCommit = 4,
    kDepth = 5,
    EXT_NOT_SET = 0,
  };

  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
               &_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Extension& a, Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(Extension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Extension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Extension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Extension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Extension& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Extension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.Extension";
  }
  protected:
  explicit Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegisteredExtFieldNumber = 1,
    kMasterArbitrationFieldNumber = 2,
    kHistoryFieldNumber = 3,
    kCommitFieldNumber = 4,
    kDepthFieldNumber = 5,
  };
  // .gnmi_ext.RegisteredExtension registered_ext = 1;
  bool has_registered_ext() const;
  private:
  bool _internal_has_registered_ext() const;
  public:
  void clear_registered_ext();
  const ::gnmi_ext::RegisteredExtension& registered_ext() const;
  PROTOBUF_NODISCARD ::gnmi_ext::RegisteredExtension* release_registered_ext();
  ::gnmi_ext::RegisteredExtension* mutable_registered_ext();
  void set_allocated_registered_ext(::gnmi_ext::RegisteredExtension* registered_ext);
  private:
  const ::gnmi_ext::RegisteredExtension& _internal_registered_ext() const;
  ::gnmi_ext::RegisteredExtension* _internal_mutable_registered_ext();
  public:
  void unsafe_arena_set_allocated_registered_ext(
      ::gnmi_ext::RegisteredExtension* registered_ext);
  ::gnmi_ext::RegisteredExtension* unsafe_arena_release_registered_ext();

  // .gnmi_ext.MasterArbitration master_arbitration = 2;
  bool has_master_arbitration() const;
  private:
  bool _internal_has_master_arbitration() const;
  public:
  void clear_master_arbitration();
  const ::gnmi_ext::MasterArbitration& master_arbitration() const;
  PROTOBUF_NODISCARD ::gnmi_ext::MasterArbitration* release_master_arbitration();
  ::gnmi_ext::MasterArbitration* mutable_master_arbitration();
  void set_allocated_master_arbitration(::gnmi_ext::MasterArbitration* master_arbitration);
  private:
  const ::gnmi_ext::MasterArbitration& _internal_master_arbitration() const;
  ::gnmi_ext::MasterArbitration* _internal_mutable_master_arbitration();
  public:
  void unsafe_arena_set_allocated_master_arbitration(
      ::gnmi_ext::MasterArbitration* master_arbitration);
  ::gnmi_ext::MasterArbitration* unsafe_arena_release_master_arbitration();

  // .gnmi_ext.History history = 3;
  bool has_history() const;
  private:
  bool _internal_has_history() const;
  public:
  void clear_history();
  const ::gnmi_ext::History& history() const;
  PROTOBUF_NODISCARD ::gnmi_ext::History* release_history();
  ::gnmi_ext::History* mutable_history();
  void set_allocated_history(::gnmi_ext::History* history);
  private:
  const ::gnmi_ext::History& _internal_history() const;
  ::gnmi_ext::History* _internal_mutable_history();
  public:
  void unsafe_arena_set_allocated_history(
      ::gnmi_ext::History* history);
  ::gnmi_ext::History* unsafe_arena_release_history();

  // .gnmi_ext.Commit commit = 4;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::gnmi_ext::Commit& commit() const;
  PROTOBUF_NODISCARD ::gnmi_ext::Commit* release_commit();
  ::gnmi_ext::Commit* mutable_commit();
  void set_allocated_commit(::gnmi_ext::Commit* commit);
  private:
  const ::gnmi_ext::Commit& _internal_commit() const;
  ::gnmi_ext::Commit* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::gnmi_ext::Commit* commit);
  ::gnmi_ext::Commit* unsafe_arena_release_commit();

  // .gnmi_ext.Depth depth = 5;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  const ::gnmi_ext::Depth& depth() const;
  PROTOBUF_NODISCARD ::gnmi_ext::Depth* release_depth();
  ::gnmi_ext::Depth* mutable_depth();
  void set_allocated_depth(::gnmi_ext::Depth* depth);
  private:
  const ::gnmi_ext::Depth& _internal_depth() const;
  ::gnmi_ext::Depth* _internal_mutable_depth();
  public:
  void unsafe_arena_set_allocated_depth(
      ::gnmi_ext::Depth* depth);
  ::gnmi_ext::Depth* unsafe_arena_release_depth();

  void clear_ext();
  ExtCase ext_case() const;
  // @@protoc_insertion_point(class_scope:gnmi_ext.Extension)
 private:
  class _Internal;
  void set_has_registered_ext();
  void set_has_master_arbitration();
  void set_has_history();
  void set_has_commit();
  void set_has_depth();

  inline bool has_ext() const;
  inline void clear_has_ext();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ExtUnion {
    constexpr ExtUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::gnmi_ext::RegisteredExtension* registered_ext_;
    ::gnmi_ext::MasterArbitration* master_arbitration_;
    ::gnmi_ext::History* history_;
    ::gnmi_ext::Commit* commit_;
    ::gnmi_ext::Depth* depth_;
  } ext_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class RegisteredExtension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.RegisteredExtension) */ {
 public:
  inline RegisteredExtension() : RegisteredExtension(nullptr) {}
  ~RegisteredExtension() override;
  explicit constexpr RegisteredExtension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisteredExtension(const RegisteredExtension& from);
  RegisteredExtension(RegisteredExtension&& from) noexcept
    : RegisteredExtension() {
    *this = ::std::move(from);
  }

  inline RegisteredExtension& operator=(const RegisteredExtension& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisteredExtension& operator=(RegisteredExtension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisteredExtension& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisteredExtension* internal_default_instance() {
    return reinterpret_cast<const RegisteredExtension*>(
               &_RegisteredExtension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisteredExtension& a, RegisteredExtension& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisteredExtension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisteredExtension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisteredExtension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisteredExtension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisteredExtension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegisteredExtension& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisteredExtension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.RegisteredExtension";
  }
  protected:
  explicit RegisteredExtension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMsgFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes msg = 2;
  void clear_msg();
  const std::string& msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* msg);
  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string& value);
  std::string* _internal_mutable_msg();
  public:

  // .gnmi_ext.ExtensionID id = 1;
  void clear_id();
  ::gnmi_ext::ExtensionID id() const;
  void set_id(::gnmi_ext::ExtensionID value);
  private:
  ::gnmi_ext::ExtensionID _internal_id() const;
  void _internal_set_id(::gnmi_ext::ExtensionID value);
  public:

  // @@protoc_insertion_point(class_scope:gnmi_ext.RegisteredExtension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
  int id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class MasterArbitration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.MasterArbitration) */ {
 public:
  inline MasterArbitration() : MasterArbitration(nullptr) {}
  ~MasterArbitration() override;
  explicit constexpr MasterArbitration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MasterArbitration(const MasterArbitration& from);
  MasterArbitration(MasterArbitration&& from) noexcept
    : MasterArbitration() {
    *this = ::std::move(from);
  }

  inline MasterArbitration& operator=(const MasterArbitration& from) {
    CopyFrom(from);
    return *this;
  }
  inline MasterArbitration& operator=(MasterArbitration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MasterArbitration& default_instance() {
    return *internal_default_instance();
  }
  static inline const MasterArbitration* internal_default_instance() {
    return reinterpret_cast<const MasterArbitration*>(
               &_MasterArbitration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MasterArbitration& a, MasterArbitration& b) {
    a.Swap(&b);
  }
  inline void Swap(MasterArbitration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MasterArbitration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MasterArbitration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MasterArbitration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MasterArbitration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MasterArbitration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MasterArbitration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.MasterArbitration";
  }
  protected:
  explicit MasterArbitration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoleFieldNumber = 1,
    kElectionIdFieldNumber = 2,
  };
  // .gnmi_ext.Role role = 1;
  bool has_role() const;
  private:
  bool _internal_has_role() const;
  public:
  void clear_role();
  const ::gnmi_ext::Role& role() const;
  PROTOBUF_NODISCARD ::gnmi_ext::Role* release_role();
  ::gnmi_ext::Role* mutable_role();
  void set_allocated_role(::gnmi_ext::Role* role);
  private:
  const ::gnmi_ext::Role& _internal_role() const;
  ::gnmi_ext::Role* _internal_mutable_role();
  public:
  void unsafe_arena_set_allocated_role(
      ::gnmi_ext::Role* role);
  ::gnmi_ext::Role* unsafe_arena_release_role();

  // .gnmi_ext.Uint128 election_id = 2;
  bool has_election_id() const;
  private:
  bool _internal_has_election_id() const;
  public:
  void clear_election_id();
  const ::gnmi_ext::Uint128& election_id() const;
  PROTOBUF_NODISCARD ::gnmi_ext::Uint128* release_election_id();
  ::gnmi_ext::Uint128* mutable_election_id();
  void set_allocated_election_id(::gnmi_ext::Uint128* election_id);
  private:
  const ::gnmi_ext::Uint128& _internal_election_id() const;
  ::gnmi_ext::Uint128* _internal_mutable_election_id();
  public:
  void unsafe_arena_set_allocated_election_id(
      ::gnmi_ext::Uint128* election_id);
  ::gnmi_ext::Uint128* unsafe_arena_release_election_id();

  // @@protoc_insertion_point(class_scope:gnmi_ext.MasterArbitration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::gnmi_ext::Role* role_;
  ::gnmi_ext::Uint128* election_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class Uint128 final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.Uint128) */ {
 public:
  inline Uint128() : Uint128(nullptr) {}
  ~Uint128() override;
  explicit constexpr Uint128(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Uint128(const Uint128& from);
  Uint128(Uint128&& from) noexcept
    : Uint128() {
    *this = ::std::move(from);
  }

  inline Uint128& operator=(const Uint128& from) {
    CopyFrom(from);
    return *this;
  }
  inline Uint128& operator=(Uint128&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Uint128& default_instance() {
    return *internal_default_instance();
  }
  static inline const Uint128* internal_default_instance() {
    return reinterpret_cast<const Uint128*>(
               &_Uint128_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Uint128& a, Uint128& b) {
    a.Swap(&b);
  }
  inline void Swap(Uint128* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Uint128* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Uint128* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Uint128>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Uint128& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Uint128& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Uint128* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.Uint128";
  }
  protected:
  explicit Uint128(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHighFieldNumber = 1,
    kLowFieldNumber = 2,
  };
  // uint64 high = 1;
  void clear_high();
  uint64_t high() const;
  void set_high(uint64_t value);
  private:
  uint64_t _internal_high() const;
  void _internal_set_high(uint64_t value);
  public:

  // uint64 low = 2;
  void clear_low();
  uint64_t low() const;
  void set_low(uint64_t value);
  private:
  uint64_t _internal_low() const;
  void _internal_set_low(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gnmi_ext.Uint128)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t high_;
  uint64_t low_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class Role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.Role) */ {
 public:
  inline Role() : Role(nullptr) {}
  ~Role() override;
  explicit constexpr Role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Role(const Role& from);
  Role(Role&& from) noexcept
    : Role() {
    *this = ::std::move(from);
  }

  inline Role& operator=(const Role& from) {
    CopyFrom(from);
    return *this;
  }
  inline Role& operator=(Role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Role& default_instance() {
    return *internal_default_instance();
  }
  static inline const Role* internal_default_instance() {
    return reinterpret_cast<const Role*>(
               &_Role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Role& a, Role& b) {
    a.Swap(&b);
  }
  inline void Swap(Role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Role& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Role* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.Role";
  }
  protected:
  explicit Role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:gnmi_ext.Role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class History final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.History) */ {
 public:
  inline History() : History(nullptr) {}
  ~History() override;
  explicit constexpr History(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  History(const History& from);
  History(History&& from) noexcept
    : History() {
    *this = ::std::move(from);
  }

  inline History& operator=(const History& from) {
    CopyFrom(from);
    return *this;
  }
  inline History& operator=(History&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const History& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kSnapshotTime = 1,
    kRange = 2,
    REQUEST_NOT_SET = 0,
  };

  static inline const History* internal_default_instance() {
    return reinterpret_cast<const History*>(
               &_History_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(History& a, History& b) {
    a.Swap(&b);
  }
  inline void Swap(History* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(History* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  History* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<History>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const History& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const History& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(History* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.History";
  }
  protected:
  explicit History(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotTimeFieldNumber = 1,
    kRangeFieldNumber = 2,
  };
  // int64 snapshot_time = 1;
  bool has_snapshot_time() const;
  private:
  bool _internal_has_snapshot_time() const;
  public:
  void clear_snapshot_time();
  int64_t snapshot_time() const;
  void set_snapshot_time(int64_t value);
  private:
  int64_t _internal_snapshot_time() const;
  void _internal_set_snapshot_time(int64_t value);
  public:

  // .gnmi_ext.TimeRange range = 2;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::gnmi_ext::TimeRange& range() const;
  PROTOBUF_NODISCARD ::gnmi_ext::TimeRange* release_range();
  ::gnmi_ext::TimeRange* mutable_range();
  void set_allocated_range(::gnmi_ext::TimeRange* range);
  private:
  const ::gnmi_ext::TimeRange& _internal_range() const;
  ::gnmi_ext::TimeRange* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::gnmi_ext::TimeRange* range);
  ::gnmi_ext::TimeRange* unsafe_arena_release_range();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:gnmi_ext.History)
 private:
  class _Internal;
  void set_has_snapshot_time();
  void set_has_range();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int64_t snapshot_time_;
    ::gnmi_ext::TimeRange* range_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class TimeRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.TimeRange) */ {
 public:
  inline TimeRange() : TimeRange(nullptr) {}
  ~TimeRange() override;
  explicit constexpr TimeRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimeRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.TimeRange";
  }
  protected:
  explicit TimeRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // int64 start = 1;
  void clear_start();
  int64_t start() const;
  void set_start(int64_t value);
  private:
  int64_t _internal_start() const;
  void _internal_set_start(int64_t value);
  public:

  // int64 end = 2;
  void clear_end();
  int64_t end() const;
  void set_end(int64_t value);
  private:
  int64_t _internal_end() const;
  void _internal_set_end(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gnmi_ext.TimeRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t start_;
  int64_t end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class Commit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.Commit) */ {
 public:
  inline Commit() : Commit(nullptr) {}
  ~Commit() override;
  explicit constexpr Commit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Commit(const Commit& from);
  Commit(Commit&& from) noexcept
    : Commit() {
    *this = ::std::move(from);
  }

  inline Commit& operator=(const Commit& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commit& operator=(Commit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commit& default_instance() {
    return *internal_default_instance();
  }
  enum ActionCase {
    kCommit = 2,
    kConfirm = 3,
    kCancel = 4,
    kSetRollbackDuration = 5,
    ACTION_NOT_SET = 0,
  };

  static inline const Commit* internal_default_instance() {
    return reinterpret_cast<const Commit*>(
               &_Commit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Commit& a, Commit& b) {
    a.Swap(&b);
  }
  inline void Swap(Commit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Commit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Commit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Commit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.Commit";
  }
  protected:
  explicit Commit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCommitFieldNumber = 2,
    kConfirmFieldNumber = 3,
    kCancelFieldNumber = 4,
    kSetRollbackDurationFieldNumber = 5,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // .gnmi_ext.CommitRequest commit = 2;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::gnmi_ext::CommitRequest& commit() const;
  PROTOBUF_NODISCARD ::gnmi_ext::CommitRequest* release_commit();
  ::gnmi_ext::CommitRequest* mutable_commit();
  void set_allocated_commit(::gnmi_ext::CommitRequest* commit);
  private:
  const ::gnmi_ext::CommitRequest& _internal_commit() const;
  ::gnmi_ext::CommitRequest* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::gnmi_ext::CommitRequest* commit);
  ::gnmi_ext::CommitRequest* unsafe_arena_release_commit();

  // .gnmi_ext.CommitConfirm confirm = 3;
  bool has_confirm() const;
  private:
  bool _internal_has_confirm() const;
  public:
  void clear_confirm();
  const ::gnmi_ext::CommitConfirm& confirm() const;
  PROTOBUF_NODISCARD ::gnmi_ext::CommitConfirm* release_confirm();
  ::gnmi_ext::CommitConfirm* mutable_confirm();
  void set_allocated_confirm(::gnmi_ext::CommitConfirm* confirm);
  private:
  const ::gnmi_ext::CommitConfirm& _internal_confirm() const;
  ::gnmi_ext::CommitConfirm* _internal_mutable_confirm();
  public:
  void unsafe_arena_set_allocated_confirm(
      ::gnmi_ext::CommitConfirm* confirm);
  ::gnmi_ext::CommitConfirm* unsafe_arena_release_confirm();

  // .gnmi_ext.CommitCancel cancel = 4;
  bool has_cancel() const;
  private:
  bool _internal_has_cancel() const;
  public:
  void clear_cancel();
  const ::gnmi_ext::CommitCancel& cancel() const;
  PROTOBUF_NODISCARD ::gnmi_ext::CommitCancel* release_cancel();
  ::gnmi_ext::CommitCancel* mutable_cancel();
  void set_allocated_cancel(::gnmi_ext::CommitCancel* cancel);
  private:
  const ::gnmi_ext::CommitCancel& _internal_cancel() const;
  ::gnmi_ext::CommitCancel* _internal_mutable_cancel();
  public:
  void unsafe_arena_set_allocated_cancel(
      ::gnmi_ext::CommitCancel* cancel);
  ::gnmi_ext::CommitCancel* unsafe_arena_release_cancel();

  // .gnmi_ext.CommitSetRollbackDuration set_rollback_duration = 5;
  bool has_set_rollback_duration() const;
  private:
  bool _internal_has_set_rollback_duration() const;
  public:
  void clear_set_rollback_duration();
  const ::gnmi_ext::CommitSetRollbackDuration& set_rollback_duration() const;
  PROTOBUF_NODISCARD ::gnmi_ext::CommitSetRollbackDuration* release_set_rollback_duration();
  ::gnmi_ext::CommitSetRollbackDuration* mutable_set_rollback_duration();
  void set_allocated_set_rollback_duration(::gnmi_ext::CommitSetRollbackDuration* set_rollback_duration);
  private:
  const ::gnmi_ext::CommitSetRollbackDuration& _internal_set_rollback_duration() const;
  ::gnmi_ext::CommitSetRollbackDuration* _internal_mutable_set_rollback_duration();
  public:
  void unsafe_arena_set_allocated_set_rollback_duration(
      ::gnmi_ext::CommitSetRollbackDuration* set_rollback_duration);
  ::gnmi_ext::CommitSetRollbackDuration* unsafe_arena_release_set_rollback_duration();

  void clear_action();
  ActionCase action_case() const;
  // @@protoc_insertion_point(class_scope:gnmi_ext.Commit)
 private:
  class _Internal;
  void set_has_commit();
  void set_has_confirm();
  void set_has_cancel();
  void set_has_set_rollback_duration();

  inline bool has_action() const;
  inline void clear_has_action();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  union ActionUnion {
    constexpr ActionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::gnmi_ext::CommitRequest* commit_;
    ::gnmi_ext::CommitConfirm* confirm_;
    ::gnmi_ext::CommitCancel* cancel_;
    ::gnmi_ext::CommitSetRollbackDuration* set_rollback_duration_;
  } action_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class CommitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.CommitRequest) */ {
 public:
  inline CommitRequest() : CommitRequest(nullptr) {}
  ~CommitRequest() override;
  explicit constexpr CommitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitRequest(const CommitRequest& from);
  CommitRequest(CommitRequest&& from) noexcept
    : CommitRequest() {
    *this = ::std::move(from);
  }

  inline CommitRequest& operator=(const CommitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitRequest& operator=(CommitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitRequest* internal_default_instance() {
    return reinterpret_cast<const CommitRequest*>(
               &_CommitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CommitRequest& a, CommitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommitRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommitRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.CommitRequest";
  }
  protected:
  explicit CommitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollbackDurationFieldNumber = 1,
  };
  // .google.protobuf.Duration rollback_duration = 1;
  bool has_rollback_duration() const;
  private:
  bool _internal_has_rollback_duration() const;
  public:
  void clear_rollback_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& rollback_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_rollback_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_rollback_duration();
  void set_allocated_rollback_duration(::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_rollback_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_rollback_duration();
  public:
  void unsafe_arena_set_allocated_rollback_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_rollback_duration();

  // @@protoc_insertion_point(class_scope:gnmi_ext.CommitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class CommitConfirm final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:gnmi_ext.CommitConfirm) */ {
 public:
  inline CommitConfirm() : CommitConfirm(nullptr) {}
  explicit constexpr CommitConfirm(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitConfirm(const CommitConfirm& from);
  CommitConfirm(CommitConfirm&& from) noexcept
    : CommitConfirm() {
    *this = ::std::move(from);
  }

  inline CommitConfirm& operator=(const CommitConfirm& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitConfirm& operator=(CommitConfirm&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitConfirm& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitConfirm* internal_default_instance() {
    return reinterpret_cast<const CommitConfirm*>(
               &_CommitConfirm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommitConfirm& a, CommitConfirm& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitConfirm* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitConfirm* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitConfirm* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitConfirm>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitConfirm& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitConfirm& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.CommitConfirm";
  }
  protected:
  explicit CommitConfirm(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gnmi_ext.CommitConfirm)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class CommitCancel final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:gnmi_ext.CommitCancel) */ {
 public:
  inline CommitCancel() : CommitCancel(nullptr) {}
  explicit constexpr CommitCancel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitCancel(const CommitCancel& from);
  CommitCancel(CommitCancel&& from) noexcept
    : CommitCancel() {
    *this = ::std::move(from);
  }

  inline CommitCancel& operator=(const CommitCancel& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitCancel& operator=(CommitCancel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitCancel& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitCancel* internal_default_instance() {
    return reinterpret_cast<const CommitCancel*>(
               &_CommitCancel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CommitCancel& a, CommitCancel& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitCancel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitCancel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitCancel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitCancel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitCancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitCancel& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.CommitCancel";
  }
  protected:
  explicit CommitCancel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gnmi_ext.CommitCancel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class CommitSetRollbackDuration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.CommitSetRollbackDuration) */ {
 public:
  inline CommitSetRollbackDuration() : CommitSetRollbackDuration(nullptr) {}
  ~CommitSetRollbackDuration() override;
  explicit constexpr CommitSetRollbackDuration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitSetRollbackDuration(const CommitSetRollbackDuration& from);
  CommitSetRollbackDuration(CommitSetRollbackDuration&& from) noexcept
    : CommitSetRollbackDuration() {
    *this = ::std::move(from);
  }

  inline CommitSetRollbackDuration& operator=(const CommitSetRollbackDuration& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitSetRollbackDuration& operator=(CommitSetRollbackDuration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitSetRollbackDuration& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitSetRollbackDuration* internal_default_instance() {
    return reinterpret_cast<const CommitSetRollbackDuration*>(
               &_CommitSetRollbackDuration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommitSetRollbackDuration& a, CommitSetRollbackDuration& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitSetRollbackDuration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitSetRollbackDuration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitSetRollbackDuration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitSetRollbackDuration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CommitSetRollbackDuration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CommitSetRollbackDuration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CommitSetRollbackDuration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.CommitSetRollbackDuration";
  }
  protected:
  explicit CommitSetRollbackDuration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRollbackDurationFieldNumber = 1,
  };
  // .google.protobuf.Duration rollback_duration = 1;
  bool has_rollback_duration() const;
  private:
  bool _internal_has_rollback_duration() const;
  public:
  void clear_rollback_duration();
  const ::PROTOBUF_NAMESPACE_ID::Duration& rollback_duration() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Duration* release_rollback_duration();
  ::PROTOBUF_NAMESPACE_ID::Duration* mutable_rollback_duration();
  void set_allocated_rollback_duration(::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Duration& _internal_rollback_duration() const;
  ::PROTOBUF_NAMESPACE_ID::Duration* _internal_mutable_rollback_duration();
  public:
  void unsafe_arena_set_allocated_rollback_duration(
      ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration);
  ::PROTOBUF_NAMESPACE_ID::Duration* unsafe_arena_release_rollback_duration();

  // @@protoc_insertion_point(class_scope:gnmi_ext.CommitSetRollbackDuration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// -------------------------------------------------------------------

class Depth final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gnmi_ext.Depth) */ {
 public:
  inline Depth() : Depth(nullptr) {}
  ~Depth() override;
  explicit constexpr Depth(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Depth(const Depth& from);
  Depth(Depth&& from) noexcept
    : Depth() {
    *this = ::std::move(from);
  }

  inline Depth& operator=(const Depth& from) {
    CopyFrom(from);
    return *this;
  }
  inline Depth& operator=(Depth&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Depth& default_instance() {
    return *internal_default_instance();
  }
  static inline const Depth* internal_default_instance() {
    return reinterpret_cast<const Depth*>(
               &_Depth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Depth& a, Depth& b) {
    a.Swap(&b);
  }
  inline void Swap(Depth* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Depth* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Depth* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Depth>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Depth& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Depth& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Depth* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gnmi_ext.Depth";
  }
  protected:
  explicit Depth(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelFieldNumber = 1,
  };
  // uint32 level = 1;
  void clear_level();
  uint32_t level() const;
  void set_level(uint32_t value);
  private:
  uint32_t _internal_level() const;
  void _internal_set_level(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:gnmi_ext.Depth)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gnmi_5fext_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Extension

// .gnmi_ext.RegisteredExtension registered_ext = 1;
inline bool Extension::_internal_has_registered_ext() const {
  return ext_case() == kRegisteredExt;
}
inline bool Extension::has_registered_ext() const {
  return _internal_has_registered_ext();
}
inline void Extension::set_has_registered_ext() {
  _oneof_case_[0] = kRegisteredExt;
}
inline void Extension::clear_registered_ext() {
  if (_internal_has_registered_ext()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ext_.registered_ext_;
    }
    clear_has_ext();
  }
}
inline ::gnmi_ext::RegisteredExtension* Extension::release_registered_ext() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Extension.registered_ext)
  if (_internal_has_registered_ext()) {
    clear_has_ext();
      ::gnmi_ext::RegisteredExtension* temp = ext_.registered_ext_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ext_.registered_ext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::RegisteredExtension& Extension::_internal_registered_ext() const {
  return _internal_has_registered_ext()
      ? *ext_.registered_ext_
      : reinterpret_cast< ::gnmi_ext::RegisteredExtension&>(::gnmi_ext::_RegisteredExtension_default_instance_);
}
inline const ::gnmi_ext::RegisteredExtension& Extension::registered_ext() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Extension.registered_ext)
  return _internal_registered_ext();
}
inline ::gnmi_ext::RegisteredExtension* Extension::unsafe_arena_release_registered_ext() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Extension.registered_ext)
  if (_internal_has_registered_ext()) {
    clear_has_ext();
    ::gnmi_ext::RegisteredExtension* temp = ext_.registered_ext_;
    ext_.registered_ext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Extension::unsafe_arena_set_allocated_registered_ext(::gnmi_ext::RegisteredExtension* registered_ext) {
  clear_ext();
  if (registered_ext) {
    set_has_registered_ext();
    ext_.registered_ext_ = registered_ext;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Extension.registered_ext)
}
inline ::gnmi_ext::RegisteredExtension* Extension::_internal_mutable_registered_ext() {
  if (!_internal_has_registered_ext()) {
    clear_ext();
    set_has_registered_ext();
    ext_.registered_ext_ = CreateMaybeMessage< ::gnmi_ext::RegisteredExtension >(GetArenaForAllocation());
  }
  return ext_.registered_ext_;
}
inline ::gnmi_ext::RegisteredExtension* Extension::mutable_registered_ext() {
  ::gnmi_ext::RegisteredExtension* _msg = _internal_mutable_registered_ext();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Extension.registered_ext)
  return _msg;
}

// .gnmi_ext.MasterArbitration master_arbitration = 2;
inline bool Extension::_internal_has_master_arbitration() const {
  return ext_case() == kMasterArbitration;
}
inline bool Extension::has_master_arbitration() const {
  return _internal_has_master_arbitration();
}
inline void Extension::set_has_master_arbitration() {
  _oneof_case_[0] = kMasterArbitration;
}
inline void Extension::clear_master_arbitration() {
  if (_internal_has_master_arbitration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ext_.master_arbitration_;
    }
    clear_has_ext();
  }
}
inline ::gnmi_ext::MasterArbitration* Extension::release_master_arbitration() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Extension.master_arbitration)
  if (_internal_has_master_arbitration()) {
    clear_has_ext();
      ::gnmi_ext::MasterArbitration* temp = ext_.master_arbitration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ext_.master_arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::MasterArbitration& Extension::_internal_master_arbitration() const {
  return _internal_has_master_arbitration()
      ? *ext_.master_arbitration_
      : reinterpret_cast< ::gnmi_ext::MasterArbitration&>(::gnmi_ext::_MasterArbitration_default_instance_);
}
inline const ::gnmi_ext::MasterArbitration& Extension::master_arbitration() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Extension.master_arbitration)
  return _internal_master_arbitration();
}
inline ::gnmi_ext::MasterArbitration* Extension::unsafe_arena_release_master_arbitration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Extension.master_arbitration)
  if (_internal_has_master_arbitration()) {
    clear_has_ext();
    ::gnmi_ext::MasterArbitration* temp = ext_.master_arbitration_;
    ext_.master_arbitration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Extension::unsafe_arena_set_allocated_master_arbitration(::gnmi_ext::MasterArbitration* master_arbitration) {
  clear_ext();
  if (master_arbitration) {
    set_has_master_arbitration();
    ext_.master_arbitration_ = master_arbitration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Extension.master_arbitration)
}
inline ::gnmi_ext::MasterArbitration* Extension::_internal_mutable_master_arbitration() {
  if (!_internal_has_master_arbitration()) {
    clear_ext();
    set_has_master_arbitration();
    ext_.master_arbitration_ = CreateMaybeMessage< ::gnmi_ext::MasterArbitration >(GetArenaForAllocation());
  }
  return ext_.master_arbitration_;
}
inline ::gnmi_ext::MasterArbitration* Extension::mutable_master_arbitration() {
  ::gnmi_ext::MasterArbitration* _msg = _internal_mutable_master_arbitration();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Extension.master_arbitration)
  return _msg;
}

// .gnmi_ext.History history = 3;
inline bool Extension::_internal_has_history() const {
  return ext_case() == kHistory;
}
inline bool Extension::has_history() const {
  return _internal_has_history();
}
inline void Extension::set_has_history() {
  _oneof_case_[0] = kHistory;
}
inline void Extension::clear_history() {
  if (_internal_has_history()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ext_.history_;
    }
    clear_has_ext();
  }
}
inline ::gnmi_ext::History* Extension::release_history() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Extension.history)
  if (_internal_has_history()) {
    clear_has_ext();
      ::gnmi_ext::History* temp = ext_.history_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ext_.history_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::History& Extension::_internal_history() const {
  return _internal_has_history()
      ? *ext_.history_
      : reinterpret_cast< ::gnmi_ext::History&>(::gnmi_ext::_History_default_instance_);
}
inline const ::gnmi_ext::History& Extension::history() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Extension.history)
  return _internal_history();
}
inline ::gnmi_ext::History* Extension::unsafe_arena_release_history() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Extension.history)
  if (_internal_has_history()) {
    clear_has_ext();
    ::gnmi_ext::History* temp = ext_.history_;
    ext_.history_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Extension::unsafe_arena_set_allocated_history(::gnmi_ext::History* history) {
  clear_ext();
  if (history) {
    set_has_history();
    ext_.history_ = history;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Extension.history)
}
inline ::gnmi_ext::History* Extension::_internal_mutable_history() {
  if (!_internal_has_history()) {
    clear_ext();
    set_has_history();
    ext_.history_ = CreateMaybeMessage< ::gnmi_ext::History >(GetArenaForAllocation());
  }
  return ext_.history_;
}
inline ::gnmi_ext::History* Extension::mutable_history() {
  ::gnmi_ext::History* _msg = _internal_mutable_history();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Extension.history)
  return _msg;
}

// .gnmi_ext.Commit commit = 4;
inline bool Extension::_internal_has_commit() const {
  return ext_case() == kCommit;
}
inline bool Extension::has_commit() const {
  return _internal_has_commit();
}
inline void Extension::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Extension::clear_commit() {
  if (_internal_has_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ext_.commit_;
    }
    clear_has_ext();
  }
}
inline ::gnmi_ext::Commit* Extension::release_commit() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Extension.commit)
  if (_internal_has_commit()) {
    clear_has_ext();
      ::gnmi_ext::Commit* temp = ext_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ext_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::Commit& Extension::_internal_commit() const {
  return _internal_has_commit()
      ? *ext_.commit_
      : reinterpret_cast< ::gnmi_ext::Commit&>(::gnmi_ext::_Commit_default_instance_);
}
inline const ::gnmi_ext::Commit& Extension::commit() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Extension.commit)
  return _internal_commit();
}
inline ::gnmi_ext::Commit* Extension::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Extension.commit)
  if (_internal_has_commit()) {
    clear_has_ext();
    ::gnmi_ext::Commit* temp = ext_.commit_;
    ext_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Extension::unsafe_arena_set_allocated_commit(::gnmi_ext::Commit* commit) {
  clear_ext();
  if (commit) {
    set_has_commit();
    ext_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Extension.commit)
}
inline ::gnmi_ext::Commit* Extension::_internal_mutable_commit() {
  if (!_internal_has_commit()) {
    clear_ext();
    set_has_commit();
    ext_.commit_ = CreateMaybeMessage< ::gnmi_ext::Commit >(GetArenaForAllocation());
  }
  return ext_.commit_;
}
inline ::gnmi_ext::Commit* Extension::mutable_commit() {
  ::gnmi_ext::Commit* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Extension.commit)
  return _msg;
}

// .gnmi_ext.Depth depth = 5;
inline bool Extension::_internal_has_depth() const {
  return ext_case() == kDepth;
}
inline bool Extension::has_depth() const {
  return _internal_has_depth();
}
inline void Extension::set_has_depth() {
  _oneof_case_[0] = kDepth;
}
inline void Extension::clear_depth() {
  if (_internal_has_depth()) {
    if (GetArenaForAllocation() == nullptr) {
      delete ext_.depth_;
    }
    clear_has_ext();
  }
}
inline ::gnmi_ext::Depth* Extension::release_depth() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Extension.depth)
  if (_internal_has_depth()) {
    clear_has_ext();
      ::gnmi_ext::Depth* temp = ext_.depth_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ext_.depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::Depth& Extension::_internal_depth() const {
  return _internal_has_depth()
      ? *ext_.depth_
      : reinterpret_cast< ::gnmi_ext::Depth&>(::gnmi_ext::_Depth_default_instance_);
}
inline const ::gnmi_ext::Depth& Extension::depth() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Extension.depth)
  return _internal_depth();
}
inline ::gnmi_ext::Depth* Extension::unsafe_arena_release_depth() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Extension.depth)
  if (_internal_has_depth()) {
    clear_has_ext();
    ::gnmi_ext::Depth* temp = ext_.depth_;
    ext_.depth_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Extension::unsafe_arena_set_allocated_depth(::gnmi_ext::Depth* depth) {
  clear_ext();
  if (depth) {
    set_has_depth();
    ext_.depth_ = depth;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Extension.depth)
}
inline ::gnmi_ext::Depth* Extension::_internal_mutable_depth() {
  if (!_internal_has_depth()) {
    clear_ext();
    set_has_depth();
    ext_.depth_ = CreateMaybeMessage< ::gnmi_ext::Depth >(GetArenaForAllocation());
  }
  return ext_.depth_;
}
inline ::gnmi_ext::Depth* Extension::mutable_depth() {
  ::gnmi_ext::Depth* _msg = _internal_mutable_depth();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Extension.depth)
  return _msg;
}

inline bool Extension::has_ext() const {
  return ext_case() != EXT_NOT_SET;
}
inline void Extension::clear_has_ext() {
  _oneof_case_[0] = EXT_NOT_SET;
}
inline Extension::ExtCase Extension::ext_case() const {
  return Extension::ExtCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisteredExtension

// .gnmi_ext.ExtensionID id = 1;
inline void RegisteredExtension::clear_id() {
  id_ = 0;
}
inline ::gnmi_ext::ExtensionID RegisteredExtension::_internal_id() const {
  return static_cast< ::gnmi_ext::ExtensionID >(id_);
}
inline ::gnmi_ext::ExtensionID RegisteredExtension::id() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.RegisteredExtension.id)
  return _internal_id();
}
inline void RegisteredExtension::_internal_set_id(::gnmi_ext::ExtensionID value) {
  
  id_ = value;
}
inline void RegisteredExtension::set_id(::gnmi_ext::ExtensionID value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.RegisteredExtension.id)
}

// bytes msg = 2;
inline void RegisteredExtension::clear_msg() {
  msg_.ClearToEmpty();
}
inline const std::string& RegisteredExtension::msg() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.RegisteredExtension.msg)
  return _internal_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisteredExtension::set_msg(ArgT0&& arg0, ArgT... args) {
 
 msg_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnmi_ext.RegisteredExtension.msg)
}
inline std::string* RegisteredExtension::mutable_msg() {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.RegisteredExtension.msg)
  return _s;
}
inline const std::string& RegisteredExtension::_internal_msg() const {
  return msg_.Get();
}
inline void RegisteredExtension::_internal_set_msg(const std::string& value) {
  
  msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegisteredExtension::_internal_mutable_msg() {
  
  return msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegisteredExtension::release_msg() {
  // @@protoc_insertion_point(field_release:gnmi_ext.RegisteredExtension.msg)
  return msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegisteredExtension::set_allocated_msg(std::string* msg) {
  if (msg != nullptr) {
    
  } else {
    
  }
  msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.RegisteredExtension.msg)
}

// -------------------------------------------------------------------

// MasterArbitration

// .gnmi_ext.Role role = 1;
inline bool MasterArbitration::_internal_has_role() const {
  return this != internal_default_instance() && role_ != nullptr;
}
inline bool MasterArbitration::has_role() const {
  return _internal_has_role();
}
inline void MasterArbitration::clear_role() {
  if (GetArenaForAllocation() == nullptr && role_ != nullptr) {
    delete role_;
  }
  role_ = nullptr;
}
inline const ::gnmi_ext::Role& MasterArbitration::_internal_role() const {
  const ::gnmi_ext::Role* p = role_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnmi_ext::Role&>(
      ::gnmi_ext::_Role_default_instance_);
}
inline const ::gnmi_ext::Role& MasterArbitration::role() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.MasterArbitration.role)
  return _internal_role();
}
inline void MasterArbitration::unsafe_arena_set_allocated_role(
    ::gnmi_ext::Role* role) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(role_);
  }
  role_ = role;
  if (role) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.MasterArbitration.role)
}
inline ::gnmi_ext::Role* MasterArbitration::release_role() {
  
  ::gnmi_ext::Role* temp = role_;
  role_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnmi_ext::Role* MasterArbitration::unsafe_arena_release_role() {
  // @@protoc_insertion_point(field_release:gnmi_ext.MasterArbitration.role)
  
  ::gnmi_ext::Role* temp = role_;
  role_ = nullptr;
  return temp;
}
inline ::gnmi_ext::Role* MasterArbitration::_internal_mutable_role() {
  
  if (role_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnmi_ext::Role>(GetArenaForAllocation());
    role_ = p;
  }
  return role_;
}
inline ::gnmi_ext::Role* MasterArbitration::mutable_role() {
  ::gnmi_ext::Role* _msg = _internal_mutable_role();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.MasterArbitration.role)
  return _msg;
}
inline void MasterArbitration::set_allocated_role(::gnmi_ext::Role* role) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete role_;
  }
  if (role) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gnmi_ext::Role>::GetOwningArena(role);
    if (message_arena != submessage_arena) {
      role = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    
  } else {
    
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.MasterArbitration.role)
}

// .gnmi_ext.Uint128 election_id = 2;
inline bool MasterArbitration::_internal_has_election_id() const {
  return this != internal_default_instance() && election_id_ != nullptr;
}
inline bool MasterArbitration::has_election_id() const {
  return _internal_has_election_id();
}
inline void MasterArbitration::clear_election_id() {
  if (GetArenaForAllocation() == nullptr && election_id_ != nullptr) {
    delete election_id_;
  }
  election_id_ = nullptr;
}
inline const ::gnmi_ext::Uint128& MasterArbitration::_internal_election_id() const {
  const ::gnmi_ext::Uint128* p = election_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::gnmi_ext::Uint128&>(
      ::gnmi_ext::_Uint128_default_instance_);
}
inline const ::gnmi_ext::Uint128& MasterArbitration::election_id() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.MasterArbitration.election_id)
  return _internal_election_id();
}
inline void MasterArbitration::unsafe_arena_set_allocated_election_id(
    ::gnmi_ext::Uint128* election_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(election_id_);
  }
  election_id_ = election_id;
  if (election_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.MasterArbitration.election_id)
}
inline ::gnmi_ext::Uint128* MasterArbitration::release_election_id() {
  
  ::gnmi_ext::Uint128* temp = election_id_;
  election_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::gnmi_ext::Uint128* MasterArbitration::unsafe_arena_release_election_id() {
  // @@protoc_insertion_point(field_release:gnmi_ext.MasterArbitration.election_id)
  
  ::gnmi_ext::Uint128* temp = election_id_;
  election_id_ = nullptr;
  return temp;
}
inline ::gnmi_ext::Uint128* MasterArbitration::_internal_mutable_election_id() {
  
  if (election_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::gnmi_ext::Uint128>(GetArenaForAllocation());
    election_id_ = p;
  }
  return election_id_;
}
inline ::gnmi_ext::Uint128* MasterArbitration::mutable_election_id() {
  ::gnmi_ext::Uint128* _msg = _internal_mutable_election_id();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.MasterArbitration.election_id)
  return _msg;
}
inline void MasterArbitration::set_allocated_election_id(::gnmi_ext::Uint128* election_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete election_id_;
  }
  if (election_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::gnmi_ext::Uint128>::GetOwningArena(election_id);
    if (message_arena != submessage_arena) {
      election_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, election_id, submessage_arena);
    }
    
  } else {
    
  }
  election_id_ = election_id;
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.MasterArbitration.election_id)
}

// -------------------------------------------------------------------

// Uint128

// uint64 high = 1;
inline void Uint128::clear_high() {
  high_ = uint64_t{0u};
}
inline uint64_t Uint128::_internal_high() const {
  return high_;
}
inline uint64_t Uint128::high() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Uint128.high)
  return _internal_high();
}
inline void Uint128::_internal_set_high(uint64_t value) {
  
  high_ = value;
}
inline void Uint128::set_high(uint64_t value) {
  _internal_set_high(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.Uint128.high)
}

// uint64 low = 2;
inline void Uint128::clear_low() {
  low_ = uint64_t{0u};
}
inline uint64_t Uint128::_internal_low() const {
  return low_;
}
inline uint64_t Uint128::low() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Uint128.low)
  return _internal_low();
}
inline void Uint128::_internal_set_low(uint64_t value) {
  
  low_ = value;
}
inline void Uint128::set_low(uint64_t value) {
  _internal_set_low(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.Uint128.low)
}

// -------------------------------------------------------------------

// Role

// string id = 1;
inline void Role::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Role::id() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Role.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Role::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnmi_ext.Role.id)
}
inline std::string* Role::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Role.id)
  return _s;
}
inline const std::string& Role::_internal_id() const {
  return id_.Get();
}
inline void Role::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Role::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Role::release_id() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Role.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Role::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.Role.id)
}

// -------------------------------------------------------------------

// History

// int64 snapshot_time = 1;
inline bool History::_internal_has_snapshot_time() const {
  return request_case() == kSnapshotTime;
}
inline bool History::has_snapshot_time() const {
  return _internal_has_snapshot_time();
}
inline void History::set_has_snapshot_time() {
  _oneof_case_[0] = kSnapshotTime;
}
inline void History::clear_snapshot_time() {
  if (_internal_has_snapshot_time()) {
    request_.snapshot_time_ = int64_t{0};
    clear_has_request();
  }
}
inline int64_t History::_internal_snapshot_time() const {
  if (_internal_has_snapshot_time()) {
    return request_.snapshot_time_;
  }
  return int64_t{0};
}
inline void History::_internal_set_snapshot_time(int64_t value) {
  if (!_internal_has_snapshot_time()) {
    clear_request();
    set_has_snapshot_time();
  }
  request_.snapshot_time_ = value;
}
inline int64_t History::snapshot_time() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.History.snapshot_time)
  return _internal_snapshot_time();
}
inline void History::set_snapshot_time(int64_t value) {
  _internal_set_snapshot_time(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.History.snapshot_time)
}

// .gnmi_ext.TimeRange range = 2;
inline bool History::_internal_has_range() const {
  return request_case() == kRange;
}
inline bool History::has_range() const {
  return _internal_has_range();
}
inline void History::set_has_range() {
  _oneof_case_[0] = kRange;
}
inline void History::clear_range() {
  if (_internal_has_range()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.range_;
    }
    clear_has_request();
  }
}
inline ::gnmi_ext::TimeRange* History::release_range() {
  // @@protoc_insertion_point(field_release:gnmi_ext.History.range)
  if (_internal_has_range()) {
    clear_has_request();
      ::gnmi_ext::TimeRange* temp = request_.range_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::TimeRange& History::_internal_range() const {
  return _internal_has_range()
      ? *request_.range_
      : reinterpret_cast< ::gnmi_ext::TimeRange&>(::gnmi_ext::_TimeRange_default_instance_);
}
inline const ::gnmi_ext::TimeRange& History::range() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.History.range)
  return _internal_range();
}
inline ::gnmi_ext::TimeRange* History::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.History.range)
  if (_internal_has_range()) {
    clear_has_request();
    ::gnmi_ext::TimeRange* temp = request_.range_;
    request_.range_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void History::unsafe_arena_set_allocated_range(::gnmi_ext::TimeRange* range) {
  clear_request();
  if (range) {
    set_has_range();
    request_.range_ = range;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.History.range)
}
inline ::gnmi_ext::TimeRange* History::_internal_mutable_range() {
  if (!_internal_has_range()) {
    clear_request();
    set_has_range();
    request_.range_ = CreateMaybeMessage< ::gnmi_ext::TimeRange >(GetArenaForAllocation());
  }
  return request_.range_;
}
inline ::gnmi_ext::TimeRange* History::mutable_range() {
  ::gnmi_ext::TimeRange* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.History.range)
  return _msg;
}

inline bool History::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void History::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline History::RequestCase History::request_case() const {
  return History::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TimeRange

// int64 start = 1;
inline void TimeRange::clear_start() {
  start_ = int64_t{0};
}
inline int64_t TimeRange::_internal_start() const {
  return start_;
}
inline int64_t TimeRange::start() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.TimeRange.start)
  return _internal_start();
}
inline void TimeRange::_internal_set_start(int64_t value) {
  
  start_ = value;
}
inline void TimeRange::set_start(int64_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.TimeRange.start)
}

// int64 end = 2;
inline void TimeRange::clear_end() {
  end_ = int64_t{0};
}
inline int64_t TimeRange::_internal_end() const {
  return end_;
}
inline int64_t TimeRange::end() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.TimeRange.end)
  return _internal_end();
}
inline void TimeRange::_internal_set_end(int64_t value) {
  
  end_ = value;
}
inline void TimeRange::set_end(int64_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.TimeRange.end)
}

// -------------------------------------------------------------------

// Commit

// string id = 1;
inline void Commit::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Commit::id() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Commit.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Commit::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gnmi_ext.Commit.id)
}
inline std::string* Commit::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Commit.id)
  return _s;
}
inline const std::string& Commit::_internal_id() const {
  return id_.Get();
}
inline void Commit::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Commit::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Commit::release_id() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Commit.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Commit::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.Commit.id)
}

// .gnmi_ext.CommitRequest commit = 2;
inline bool Commit::_internal_has_commit() const {
  return action_case() == kCommit;
}
inline bool Commit::has_commit() const {
  return _internal_has_commit();
}
inline void Commit::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Commit::clear_commit() {
  if (_internal_has_commit()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_.commit_;
    }
    clear_has_action();
  }
}
inline ::gnmi_ext::CommitRequest* Commit::release_commit() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Commit.commit)
  if (_internal_has_commit()) {
    clear_has_action();
      ::gnmi_ext::CommitRequest* temp = action_.commit_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::CommitRequest& Commit::_internal_commit() const {
  return _internal_has_commit()
      ? *action_.commit_
      : reinterpret_cast< ::gnmi_ext::CommitRequest&>(::gnmi_ext::_CommitRequest_default_instance_);
}
inline const ::gnmi_ext::CommitRequest& Commit::commit() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Commit.commit)
  return _internal_commit();
}
inline ::gnmi_ext::CommitRequest* Commit::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Commit.commit)
  if (_internal_has_commit()) {
    clear_has_action();
    ::gnmi_ext::CommitRequest* temp = action_.commit_;
    action_.commit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Commit::unsafe_arena_set_allocated_commit(::gnmi_ext::CommitRequest* commit) {
  clear_action();
  if (commit) {
    set_has_commit();
    action_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Commit.commit)
}
inline ::gnmi_ext::CommitRequest* Commit::_internal_mutable_commit() {
  if (!_internal_has_commit()) {
    clear_action();
    set_has_commit();
    action_.commit_ = CreateMaybeMessage< ::gnmi_ext::CommitRequest >(GetArenaForAllocation());
  }
  return action_.commit_;
}
inline ::gnmi_ext::CommitRequest* Commit::mutable_commit() {
  ::gnmi_ext::CommitRequest* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Commit.commit)
  return _msg;
}

// .gnmi_ext.CommitConfirm confirm = 3;
inline bool Commit::_internal_has_confirm() const {
  return action_case() == kConfirm;
}
inline bool Commit::has_confirm() const {
  return _internal_has_confirm();
}
inline void Commit::set_has_confirm() {
  _oneof_case_[0] = kConfirm;
}
inline void Commit::clear_confirm() {
  if (_internal_has_confirm()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_.confirm_;
    }
    clear_has_action();
  }
}
inline ::gnmi_ext::CommitConfirm* Commit::release_confirm() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Commit.confirm)
  if (_internal_has_confirm()) {
    clear_has_action();
      ::gnmi_ext::CommitConfirm* temp = action_.confirm_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.confirm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::CommitConfirm& Commit::_internal_confirm() const {
  return _internal_has_confirm()
      ? *action_.confirm_
      : reinterpret_cast< ::gnmi_ext::CommitConfirm&>(::gnmi_ext::_CommitConfirm_default_instance_);
}
inline const ::gnmi_ext::CommitConfirm& Commit::confirm() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Commit.confirm)
  return _internal_confirm();
}
inline ::gnmi_ext::CommitConfirm* Commit::unsafe_arena_release_confirm() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Commit.confirm)
  if (_internal_has_confirm()) {
    clear_has_action();
    ::gnmi_ext::CommitConfirm* temp = action_.confirm_;
    action_.confirm_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Commit::unsafe_arena_set_allocated_confirm(::gnmi_ext::CommitConfirm* confirm) {
  clear_action();
  if (confirm) {
    set_has_confirm();
    action_.confirm_ = confirm;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Commit.confirm)
}
inline ::gnmi_ext::CommitConfirm* Commit::_internal_mutable_confirm() {
  if (!_internal_has_confirm()) {
    clear_action();
    set_has_confirm();
    action_.confirm_ = CreateMaybeMessage< ::gnmi_ext::CommitConfirm >(GetArenaForAllocation());
  }
  return action_.confirm_;
}
inline ::gnmi_ext::CommitConfirm* Commit::mutable_confirm() {
  ::gnmi_ext::CommitConfirm* _msg = _internal_mutable_confirm();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Commit.confirm)
  return _msg;
}

// .gnmi_ext.CommitCancel cancel = 4;
inline bool Commit::_internal_has_cancel() const {
  return action_case() == kCancel;
}
inline bool Commit::has_cancel() const {
  return _internal_has_cancel();
}
inline void Commit::set_has_cancel() {
  _oneof_case_[0] = kCancel;
}
inline void Commit::clear_cancel() {
  if (_internal_has_cancel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_.cancel_;
    }
    clear_has_action();
  }
}
inline ::gnmi_ext::CommitCancel* Commit::release_cancel() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Commit.cancel)
  if (_internal_has_cancel()) {
    clear_has_action();
      ::gnmi_ext::CommitCancel* temp = action_.cancel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::CommitCancel& Commit::_internal_cancel() const {
  return _internal_has_cancel()
      ? *action_.cancel_
      : reinterpret_cast< ::gnmi_ext::CommitCancel&>(::gnmi_ext::_CommitCancel_default_instance_);
}
inline const ::gnmi_ext::CommitCancel& Commit::cancel() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Commit.cancel)
  return _internal_cancel();
}
inline ::gnmi_ext::CommitCancel* Commit::unsafe_arena_release_cancel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Commit.cancel)
  if (_internal_has_cancel()) {
    clear_has_action();
    ::gnmi_ext::CommitCancel* temp = action_.cancel_;
    action_.cancel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Commit::unsafe_arena_set_allocated_cancel(::gnmi_ext::CommitCancel* cancel) {
  clear_action();
  if (cancel) {
    set_has_cancel();
    action_.cancel_ = cancel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Commit.cancel)
}
inline ::gnmi_ext::CommitCancel* Commit::_internal_mutable_cancel() {
  if (!_internal_has_cancel()) {
    clear_action();
    set_has_cancel();
    action_.cancel_ = CreateMaybeMessage< ::gnmi_ext::CommitCancel >(GetArenaForAllocation());
  }
  return action_.cancel_;
}
inline ::gnmi_ext::CommitCancel* Commit::mutable_cancel() {
  ::gnmi_ext::CommitCancel* _msg = _internal_mutable_cancel();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Commit.cancel)
  return _msg;
}

// .gnmi_ext.CommitSetRollbackDuration set_rollback_duration = 5;
inline bool Commit::_internal_has_set_rollback_duration() const {
  return action_case() == kSetRollbackDuration;
}
inline bool Commit::has_set_rollback_duration() const {
  return _internal_has_set_rollback_duration();
}
inline void Commit::set_has_set_rollback_duration() {
  _oneof_case_[0] = kSetRollbackDuration;
}
inline void Commit::clear_set_rollback_duration() {
  if (_internal_has_set_rollback_duration()) {
    if (GetArenaForAllocation() == nullptr) {
      delete action_.set_rollback_duration_;
    }
    clear_has_action();
  }
}
inline ::gnmi_ext::CommitSetRollbackDuration* Commit::release_set_rollback_duration() {
  // @@protoc_insertion_point(field_release:gnmi_ext.Commit.set_rollback_duration)
  if (_internal_has_set_rollback_duration()) {
    clear_has_action();
      ::gnmi_ext::CommitSetRollbackDuration* temp = action_.set_rollback_duration_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    action_.set_rollback_duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::gnmi_ext::CommitSetRollbackDuration& Commit::_internal_set_rollback_duration() const {
  return _internal_has_set_rollback_duration()
      ? *action_.set_rollback_duration_
      : reinterpret_cast< ::gnmi_ext::CommitSetRollbackDuration&>(::gnmi_ext::_CommitSetRollbackDuration_default_instance_);
}
inline const ::gnmi_ext::CommitSetRollbackDuration& Commit::set_rollback_duration() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Commit.set_rollback_duration)
  return _internal_set_rollback_duration();
}
inline ::gnmi_ext::CommitSetRollbackDuration* Commit::unsafe_arena_release_set_rollback_duration() {
  // @@protoc_insertion_point(field_unsafe_arena_release:gnmi_ext.Commit.set_rollback_duration)
  if (_internal_has_set_rollback_duration()) {
    clear_has_action();
    ::gnmi_ext::CommitSetRollbackDuration* temp = action_.set_rollback_duration_;
    action_.set_rollback_duration_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Commit::unsafe_arena_set_allocated_set_rollback_duration(::gnmi_ext::CommitSetRollbackDuration* set_rollback_duration) {
  clear_action();
  if (set_rollback_duration) {
    set_has_set_rollback_duration();
    action_.set_rollback_duration_ = set_rollback_duration;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.Commit.set_rollback_duration)
}
inline ::gnmi_ext::CommitSetRollbackDuration* Commit::_internal_mutable_set_rollback_duration() {
  if (!_internal_has_set_rollback_duration()) {
    clear_action();
    set_has_set_rollback_duration();
    action_.set_rollback_duration_ = CreateMaybeMessage< ::gnmi_ext::CommitSetRollbackDuration >(GetArenaForAllocation());
  }
  return action_.set_rollback_duration_;
}
inline ::gnmi_ext::CommitSetRollbackDuration* Commit::mutable_set_rollback_duration() {
  ::gnmi_ext::CommitSetRollbackDuration* _msg = _internal_mutable_set_rollback_duration();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.Commit.set_rollback_duration)
  return _msg;
}

inline bool Commit::has_action() const {
  return action_case() != ACTION_NOT_SET;
}
inline void Commit::clear_has_action() {
  _oneof_case_[0] = ACTION_NOT_SET;
}
inline Commit::ActionCase Commit::action_case() const {
  return Commit::ActionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommitRequest

// .google.protobuf.Duration rollback_duration = 1;
inline bool CommitRequest::_internal_has_rollback_duration() const {
  return this != internal_default_instance() && rollback_duration_ != nullptr;
}
inline bool CommitRequest::has_rollback_duration() const {
  return _internal_has_rollback_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CommitRequest::_internal_rollback_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = rollback_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CommitRequest::rollback_duration() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.CommitRequest.rollback_duration)
  return _internal_rollback_duration();
}
inline void CommitRequest::unsafe_arena_set_allocated_rollback_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration_);
  }
  rollback_duration_ = rollback_duration;
  if (rollback_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.CommitRequest.rollback_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitRequest::release_rollback_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = rollback_duration_;
  rollback_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitRequest::unsafe_arena_release_rollback_duration() {
  // @@protoc_insertion_point(field_release:gnmi_ext.CommitRequest.rollback_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = rollback_duration_;
  rollback_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitRequest::_internal_mutable_rollback_duration() {
  
  if (rollback_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    rollback_duration_ = p;
  }
  return rollback_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitRequest::mutable_rollback_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_rollback_duration();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.CommitRequest.rollback_duration)
  return _msg;
}
inline void CommitRequest::set_allocated_rollback_duration(::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration_);
  }
  if (rollback_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration));
    if (message_arena != submessage_arena) {
      rollback_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rollback_duration, submessage_arena);
    }
    
  } else {
    
  }
  rollback_duration_ = rollback_duration;
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.CommitRequest.rollback_duration)
}

// -------------------------------------------------------------------

// CommitConfirm

// -------------------------------------------------------------------

// CommitCancel

// -------------------------------------------------------------------

// CommitSetRollbackDuration

// .google.protobuf.Duration rollback_duration = 1;
inline bool CommitSetRollbackDuration::_internal_has_rollback_duration() const {
  return this != internal_default_instance() && rollback_duration_ != nullptr;
}
inline bool CommitSetRollbackDuration::has_rollback_duration() const {
  return _internal_has_rollback_duration();
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CommitSetRollbackDuration::_internal_rollback_duration() const {
  const ::PROTOBUF_NAMESPACE_ID::Duration* p = rollback_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Duration&>(
      ::PROTOBUF_NAMESPACE_ID::_Duration_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Duration& CommitSetRollbackDuration::rollback_duration() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.CommitSetRollbackDuration.rollback_duration)
  return _internal_rollback_duration();
}
inline void CommitSetRollbackDuration::unsafe_arena_set_allocated_rollback_duration(
    ::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration_);
  }
  rollback_duration_ = rollback_duration;
  if (rollback_duration) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:gnmi_ext.CommitSetRollbackDuration.rollback_duration)
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitSetRollbackDuration::release_rollback_duration() {
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = rollback_duration_;
  rollback_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitSetRollbackDuration::unsafe_arena_release_rollback_duration() {
  // @@protoc_insertion_point(field_release:gnmi_ext.CommitSetRollbackDuration.rollback_duration)
  
  ::PROTOBUF_NAMESPACE_ID::Duration* temp = rollback_duration_;
  rollback_duration_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitSetRollbackDuration::_internal_mutable_rollback_duration() {
  
  if (rollback_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Duration>(GetArenaForAllocation());
    rollback_duration_ = p;
  }
  return rollback_duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::Duration* CommitSetRollbackDuration::mutable_rollback_duration() {
  ::PROTOBUF_NAMESPACE_ID::Duration* _msg = _internal_mutable_rollback_duration();
  // @@protoc_insertion_point(field_mutable:gnmi_ext.CommitSetRollbackDuration.rollback_duration)
  return _msg;
}
inline void CommitSetRollbackDuration::set_allocated_rollback_duration(::PROTOBUF_NAMESPACE_ID::Duration* rollback_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration_);
  }
  if (rollback_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rollback_duration));
    if (message_arena != submessage_arena) {
      rollback_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rollback_duration, submessage_arena);
    }
    
  } else {
    
  }
  rollback_duration_ = rollback_duration;
  // @@protoc_insertion_point(field_set_allocated:gnmi_ext.CommitSetRollbackDuration.rollback_duration)
}

// -------------------------------------------------------------------

// Depth

// uint32 level = 1;
inline void Depth::clear_level() {
  level_ = 0u;
}
inline uint32_t Depth::_internal_level() const {
  return level_;
}
inline uint32_t Depth::level() const {
  // @@protoc_insertion_point(field_get:gnmi_ext.Depth.level)
  return _internal_level();
}
inline void Depth::_internal_set_level(uint32_t value) {
  
  level_ = value;
}
inline void Depth::set_level(uint32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:gnmi_ext.Depth.level)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gnmi_ext

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gnmi_ext::ExtensionID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gnmi_ext::ExtensionID>() {
  return ::gnmi_ext::ExtensionID_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gnmi_5fext_2eproto
